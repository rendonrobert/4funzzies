{"ast":null,"code":"export class AudioRecorder {\n  constructor() {\n    this.mediaRecorder = null;\n    this.audioChunks = [];\n  }\n  async startRecording() {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      this.mediaRecorder = new MediaRecorder(stream);\n      this.audioChunks = [];\n      this.mediaRecorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          this.audioChunks.push(event.data);\n        }\n      };\n      this.mediaRecorder.start();\n    } catch (error) {\n      console.error('Error starting recording:', error);\n      throw error;\n    }\n  }\n  async stopRecording() {\n    return new Promise((resolve, reject) => {\n      if (!this.mediaRecorder) {\n        reject(new Error('No recording in progress'));\n        return;\n      }\n      this.mediaRecorder.onstop = () => {\n        const audioBlob = new Blob(this.audioChunks, {\n          type: 'audio/wav'\n        });\n        this.audioChunks = [];\n        resolve(audioBlob);\n      };\n      this.mediaRecorder.stop();\n      this.mediaRecorder.stream.getTracks().forEach(track => track.stop());\n    });\n  }\n}","map":{"version":3,"names":["AudioRecorder","constructor","mediaRecorder","audioChunks","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","MediaRecorder","ondataavailable","event","data","size","push","start","error","console","stopRecording","Promise","resolve","reject","Error","onstop","audioBlob","Blob","type","stop","getTracks","forEach","track"],"sources":["/Users/4funzzies/Desktop/Claude/App/frontend/src/services/audioService.ts"],"sourcesContent":["export class AudioRecorder {\n  private mediaRecorder: MediaRecorder | null = null;\n  private audioChunks: Blob[] = [];\n\n  async startRecording(): Promise<void> {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      this.mediaRecorder = new MediaRecorder(stream);\n      this.audioChunks = [];\n\n      this.mediaRecorder.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          this.audioChunks.push(event.data);\n        }\n      };\n\n      this.mediaRecorder.start();\n    } catch (error) {\n      console.error('Error starting recording:', error);\n      throw error;\n    }\n  }\n\n  async stopRecording(): Promise<Blob> {\n    return new Promise((resolve, reject) => {\n      if (!this.mediaRecorder) {\n        reject(new Error('No recording in progress'));\n        return;\n      }\n\n      this.mediaRecorder.onstop = () => {\n        const audioBlob = new Blob(this.audioChunks, { type: 'audio/wav' });\n        this.audioChunks = [];\n        resolve(audioBlob);\n      };\n\n      this.mediaRecorder.stop();\n      this.mediaRecorder.stream.getTracks().forEach(track => track.stop());\n    });\n  }\n}"],"mappings":"AAAA,OAAO,MAAMA,aAAa,CAAC;EAAAC,YAAA;IAAA,KACjBC,aAAa,GAAyB,IAAI;IAAA,KAC1CC,WAAW,GAAW,EAAE;EAAA;EAEhC,MAAMC,cAAcA,CAAA,EAAkB;IACpC,IAAI;MACF,MAAMC,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QAAEC,KAAK,EAAE;MAAK,CAAC,CAAC;MACzE,IAAI,CAACP,aAAa,GAAG,IAAIQ,aAAa,CAACL,MAAM,CAAC;MAC9C,IAAI,CAACF,WAAW,GAAG,EAAE;MAErB,IAAI,CAACD,aAAa,CAACS,eAAe,GAAIC,KAAK,IAAK;QAC9C,IAAIA,KAAK,CAACC,IAAI,CAACC,IAAI,GAAG,CAAC,EAAE;UACvB,IAAI,CAACX,WAAW,CAACY,IAAI,CAACH,KAAK,CAACC,IAAI,CAAC;QACnC;MACF,CAAC;MAED,IAAI,CAACX,aAAa,CAACc,KAAK,CAAC,CAAC;IAC5B,CAAC,CAAC,OAAOC,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;MACjD,MAAMA,KAAK;IACb;EACF;EAEA,MAAME,aAAaA,CAAA,EAAkB;IACnC,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAI,CAAC,IAAI,CAACpB,aAAa,EAAE;QACvBoB,MAAM,CAAC,IAAIC,KAAK,CAAC,0BAA0B,CAAC,CAAC;QAC7C;MACF;MAEA,IAAI,CAACrB,aAAa,CAACsB,MAAM,GAAG,MAAM;QAChC,MAAMC,SAAS,GAAG,IAAIC,IAAI,CAAC,IAAI,CAACvB,WAAW,EAAE;UAAEwB,IAAI,EAAE;QAAY,CAAC,CAAC;QACnE,IAAI,CAACxB,WAAW,GAAG,EAAE;QACrBkB,OAAO,CAACI,SAAS,CAAC;MACpB,CAAC;MAED,IAAI,CAACvB,aAAa,CAAC0B,IAAI,CAAC,CAAC;MACzB,IAAI,CAAC1B,aAAa,CAACG,MAAM,CAACwB,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACH,IAAI,CAAC,CAAC,CAAC;IACtE,CAAC,CAAC;EACJ;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
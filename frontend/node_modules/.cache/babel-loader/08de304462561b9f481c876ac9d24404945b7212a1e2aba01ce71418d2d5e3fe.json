{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useRef } from 'react';\nconst RECORDING_DURATION = 12; // seconds\n\nexport const useAudioRecorder = () => {\n  _s();\n  const [mediaRecorder, setMediaRecorder] = useState(null);\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioBlob, setAudioBlob] = useState(null);\n  const [recordingTimeLeft, setRecordingTimeLeft] = useState(RECORDING_DURATION);\n  const timerRef = useRef(null);\n  const intervalRef = useRef(null);\n  const stopRecording = useCallback(() => {\n    if (mediaRecorder && isRecording) {\n      mediaRecorder.stop();\n      setIsRecording(false);\n      setRecordingTimeLeft(RECORDING_DURATION);\n\n      // Clear timers\n      if (timerRef.current) {\n        clearTimeout(timerRef.current);\n        timerRef.current = null;\n      }\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n    }\n  }, [mediaRecorder, isRecording]);\n  const startRecording = useCallback(async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      const recorder = new MediaRecorder(stream);\n      const chunks = [];\n      recorder.ondataavailable = e => chunks.push(e.data);\n      recorder.onstop = () => {\n        const blob = new Blob(chunks, {\n          type: 'audio/webm'\n        });\n        setAudioBlob(blob);\n        stream.getTracks().forEach(track => track.stop());\n      };\n      recorder.start();\n      setMediaRecorder(recorder);\n      setIsRecording(true);\n      setRecordingTimeLeft(RECORDING_DURATION);\n\n      // Set up the countdown timer\n      intervalRef.current = setInterval(() => {\n        setRecordingTimeLeft(prev => Math.max(0, prev - 1));\n      }, 1000);\n\n      // Set up the automatic stop\n      timerRef.current = setTimeout(() => {\n        stopRecording();\n      }, RECORDING_DURATION * 1000);\n    } catch (error) {\n      console.error('Error accessing microphone:', error);\n    }\n  }, [stopRecording]);\n  return {\n    startRecording,\n    stopRecording,\n    isRecording,\n    audioBlob,\n    recordingTimeLeft\n  };\n};\n_s(useAudioRecorder, \"1eY4CkjorQODSX64xhUiJDNUZsc=\");","map":{"version":3,"names":["useState","useCallback","useRef","RECORDING_DURATION","useAudioRecorder","_s","mediaRecorder","setMediaRecorder","isRecording","setIsRecording","audioBlob","setAudioBlob","recordingTimeLeft","setRecordingTimeLeft","timerRef","intervalRef","stopRecording","stop","current","clearTimeout","clearInterval","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","recorder","MediaRecorder","chunks","ondataavailable","e","push","data","onstop","blob","Blob","type","getTracks","forEach","track","start","setInterval","prev","Math","max","setTimeout","error","console"],"sources":["/Users/4funzzies/Desktop/Claude/App1/frontend/src/hooks/useAudioRecorder.ts"],"sourcesContent":["import { useState, useCallback, useRef } from 'react';\n\ninterface AudioRecorderHook {\n  startRecording: () => Promise<void>;\n  stopRecording: () => void;\n  isRecording: boolean;\n  audioBlob: Blob | null;\n  recordingTimeLeft: number;\n}\n\nconst RECORDING_DURATION = 12; // seconds\n\nexport const useAudioRecorder = (): AudioRecorderHook => {\n  const [mediaRecorder, setMediaRecorder] = useState<MediaRecorder | null>(null);\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioBlob, setAudioBlob] = useState<Blob | null>(null);\n  const [recordingTimeLeft, setRecordingTimeLeft] = useState(RECORDING_DURATION);\n  const timerRef = useRef<NodeJS.Timeout | null>(null);\n  const intervalRef = useRef<NodeJS.Timeout | null>(null);\n\n  const stopRecording = useCallback(() => {\n    if (mediaRecorder && isRecording) {\n      mediaRecorder.stop();\n      setIsRecording(false);\n      setRecordingTimeLeft(RECORDING_DURATION);\n      \n      // Clear timers\n      if (timerRef.current) {\n        clearTimeout(timerRef.current);\n        timerRef.current = null;\n      }\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n    }\n  }, [mediaRecorder, isRecording]);\n\n  const startRecording = useCallback(async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      const recorder = new MediaRecorder(stream);\n      const chunks: BlobPart[] = [];\n\n      recorder.ondataavailable = (e) => chunks.push(e.data);\n      recorder.onstop = () => {\n        const blob = new Blob(chunks, { type: 'audio/webm' });\n        setAudioBlob(blob);\n        stream.getTracks().forEach(track => track.stop());\n      };\n\n      recorder.start();\n      setMediaRecorder(recorder);\n      setIsRecording(true);\n      setRecordingTimeLeft(RECORDING_DURATION);\n\n      // Set up the countdown timer\n      intervalRef.current = setInterval(() => {\n        setRecordingTimeLeft((prev) => Math.max(0, prev - 1));\n      }, 1000);\n\n      // Set up the automatic stop\n      timerRef.current = setTimeout(() => {\n        stopRecording();\n      }, RECORDING_DURATION * 1000);\n\n    } catch (error) {\n      console.error('Error accessing microphone:', error);\n    }\n  }, [stopRecording]);\n\n  return {\n    startRecording,\n    stopRecording,\n    isRecording,\n    audioBlob,\n    recordingTimeLeft\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
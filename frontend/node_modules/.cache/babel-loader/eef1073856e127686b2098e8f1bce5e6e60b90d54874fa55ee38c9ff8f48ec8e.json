{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback } from 'react';\nexport const useAudioRecorder = () => {\n  _s();\n  const [mediaRecorder, setMediaRecorder] = useState(null);\n  const [audioChunks, setAudioChunks] = useState([]);\n  const startRecording = useCallback(async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          echoCancellation: true,\n          noiseSuppression: true,\n          sampleRate: 44100\n        }\n      });\n      const newMediaRecorder = new MediaRecorder(stream, {\n        mimeType: 'audio/webm'\n      });\n      newMediaRecorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          setAudioChunks(chunks => [...chunks, event.data]);\n        }\n      };\n\n      // Save the mediaRecorder instance\n      setMediaRecorder(newMediaRecorder);\n\n      // Start recording\n      newMediaRecorder.start();\n      setAudioChunks([]);\n      return newMediaRecorder;\n    } catch (err) {\n      console.error('Error accessing microphone:', err);\n      throw err;\n    }\n  }, []);\n  const stopRecording = useCallback(async recorder => {\n    return new Promise((resolve, reject) => {\n      try {\n        if (!recorder || recorder.state === 'inactive') {\n          reject(new Error('No active recording'));\n          return;\n        }\n        recorder.onstop = () => {\n          const audioBlob = new Blob(audioChunks, {\n            type: 'audio/webm'\n          });\n          setAudioChunks([]);\n          setMediaRecorder(null);\n          recorder.stream.getTracks().forEach(track => track.stop());\n          resolve(audioBlob);\n        };\n        recorder.stop();\n      } catch (err) {\n        reject(err);\n      }\n    });\n  }, [audioChunks]);\n  return {\n    startRecording,\n    stopRecording\n  };\n};\n_s(useAudioRecorder, \"17GJloIFKTp+eXdcBlunuKD0UZU=\");","map":{"version":3,"names":["useState","useCallback","useAudioRecorder","_s","mediaRecorder","setMediaRecorder","audioChunks","setAudioChunks","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","echoCancellation","noiseSuppression","sampleRate","newMediaRecorder","MediaRecorder","mimeType","ondataavailable","event","data","size","chunks","start","err","console","error","stopRecording","recorder","Promise","resolve","reject","state","Error","onstop","audioBlob","Blob","type","getTracks","forEach","track","stop"],"sources":["/Users/4funzzies/Desktop/Claude/App/frontend/src/hooks/useAudioRecorder.ts"],"sourcesContent":["import { useState, useCallback } from 'react';\n\nexport const useAudioRecorder = () => {\n  const [mediaRecorder, setMediaRecorder] = useState<MediaRecorder | null>(null);\n  const [audioChunks, setAudioChunks] = useState<Blob[]>([]);\n\n  const startRecording = useCallback(async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ \n        audio: {\n          echoCancellation: true,\n          noiseSuppression: true,\n          sampleRate: 44100,\n        } \n      });\n\n      const newMediaRecorder = new MediaRecorder(stream, {\n        mimeType: 'audio/webm'\n      });\n\n      newMediaRecorder.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          setAudioChunks(chunks => [...chunks, event.data]);\n        }\n      };\n\n      // Save the mediaRecorder instance\n      setMediaRecorder(newMediaRecorder);\n\n      // Start recording\n      newMediaRecorder.start();\n      setAudioChunks([]);\n\n      return newMediaRecorder;\n    } catch (err) {\n      console.error('Error accessing microphone:', err);\n      throw err;\n    }\n  }, []);\n\n  const stopRecording = useCallback(async (recorder: MediaRecorder): Promise<Blob> => {\n    return new Promise((resolve, reject) => {\n      try {\n        if (!recorder || recorder.state === 'inactive') {\n          reject(new Error('No active recording'));\n          return;\n        }\n\n        recorder.onstop = () => {\n          const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });\n          setAudioChunks([]);\n          setMediaRecorder(null);\n          recorder.stream.getTracks().forEach(track => track.stop());\n          resolve(audioBlob);\n        };\n\n        recorder.stop();\n      } catch (err) {\n        reject(err);\n      }\n    });\n  }, [audioChunks]);\n\n  return {\n    startRecording,\n    stopRecording\n  };\n};"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,WAAW,QAAQ,OAAO;AAE7C,OAAO,MAAMC,gBAAgB,GAAGA,CAAA,KAAM;EAAAC,EAAA;EACpC,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGL,QAAQ,CAAuB,IAAI,CAAC;EAC9E,MAAM,CAACM,WAAW,EAAEC,cAAc,CAAC,GAAGP,QAAQ,CAAS,EAAE,CAAC;EAE1D,MAAMQ,cAAc,GAAGP,WAAW,CAAC,YAAY;IAC7C,IAAI;MACF,MAAMQ,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QACvDC,KAAK,EAAE;UACLC,gBAAgB,EAAE,IAAI;UACtBC,gBAAgB,EAAE,IAAI;UACtBC,UAAU,EAAE;QACd;MACF,CAAC,CAAC;MAEF,MAAMC,gBAAgB,GAAG,IAAIC,aAAa,CAACT,MAAM,EAAE;QACjDU,QAAQ,EAAE;MACZ,CAAC,CAAC;MAEFF,gBAAgB,CAACG,eAAe,GAAIC,KAAK,IAAK;QAC5C,IAAIA,KAAK,CAACC,IAAI,CAACC,IAAI,GAAG,CAAC,EAAE;UACvBhB,cAAc,CAACiB,MAAM,IAAI,CAAC,GAAGA,MAAM,EAAEH,KAAK,CAACC,IAAI,CAAC,CAAC;QACnD;MACF,CAAC;;MAED;MACAjB,gBAAgB,CAACY,gBAAgB,CAAC;;MAElC;MACAA,gBAAgB,CAACQ,KAAK,CAAC,CAAC;MACxBlB,cAAc,CAAC,EAAE,CAAC;MAElB,OAAOU,gBAAgB;IACzB,CAAC,CAAC,OAAOS,GAAG,EAAE;MACZC,OAAO,CAACC,KAAK,CAAC,6BAA6B,EAAEF,GAAG,CAAC;MACjD,MAAMA,GAAG;IACX;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMG,aAAa,GAAG5B,WAAW,CAAC,MAAO6B,QAAuB,IAAoB;IAClF,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAI;QACF,IAAI,CAACH,QAAQ,IAAIA,QAAQ,CAACI,KAAK,KAAK,UAAU,EAAE;UAC9CD,MAAM,CAAC,IAAIE,KAAK,CAAC,qBAAqB,CAAC,CAAC;UACxC;QACF;QAEAL,QAAQ,CAACM,MAAM,GAAG,MAAM;UACtB,MAAMC,SAAS,GAAG,IAAIC,IAAI,CAAChC,WAAW,EAAE;YAAEiC,IAAI,EAAE;UAAa,CAAC,CAAC;UAC/DhC,cAAc,CAAC,EAAE,CAAC;UAClBF,gBAAgB,CAAC,IAAI,CAAC;UACtByB,QAAQ,CAACrB,MAAM,CAAC+B,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACC,IAAI,CAAC,CAAC,CAAC;UAC1DX,OAAO,CAACK,SAAS,CAAC;QACpB,CAAC;QAEDP,QAAQ,CAACa,IAAI,CAAC,CAAC;MACjB,CAAC,CAAC,OAAOjB,GAAG,EAAE;QACZO,MAAM,CAACP,GAAG,CAAC;MACb;IACF,CAAC,CAAC;EACJ,CAAC,EAAE,CAACpB,WAAW,CAAC,CAAC;EAEjB,OAAO;IACLE,cAAc;IACdqB;EACF,CAAC;AACH,CAAC;AAAC1B,EAAA,CAjEWD,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
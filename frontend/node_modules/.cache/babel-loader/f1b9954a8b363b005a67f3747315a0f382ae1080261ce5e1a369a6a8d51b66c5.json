{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useRef } from 'react';\nconst RECORDING_DURATION = 12; // seconds\n\nexport const useAudioRecorder = () => {\n  _s();\n  const [mediaRecorder, setMediaRecorder] = useState(null);\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioBlob, setAudioBlob] = useState(null);\n  const timerRef = useRef(null);\n  const reset = useCallback(() => {\n    setIsRecording(false);\n    setAudioBlob(null);\n    setMediaRecorder(null);\n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n    }\n  }, []);\n  const stopRecording = useCallback(() => {\n    if (mediaRecorder && isRecording) {\n      mediaRecorder.stop();\n      setIsRecording(false);\n      if (timerRef.current) {\n        clearTimeout(timerRef.current);\n        timerRef.current = null;\n      }\n    }\n  }, [mediaRecorder, isRecording]);\n  const startRecording = useCallback(async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      const recorder = new MediaRecorder(stream);\n      const chunks = [];\n      recorder.ondataavailable = e => chunks.push(e.data);\n      recorder.onstop = () => {\n        const blob = new Blob(chunks, {\n          type: 'audio/webm'\n        });\n        setAudioBlob(blob);\n        stream.getTracks().forEach(track => track.stop());\n      };\n      recorder.start();\n      setMediaRecorder(recorder);\n      setIsRecording(true);\n\n      // Automatically stop after RECORDING_DURATION seconds\n      timerRef.current = setTimeout(() => {\n        stopRecording();\n      }, RECORDING_DURATION * 1000);\n    } catch (error) {\n      console.error('Error accessing microphone:', error);\n      reset();\n    }\n  }, [stopRecording, reset]);\n  return {\n    startRecording,\n    isRecording,\n    audioBlob,\n    reset\n  };\n};\n_s(useAudioRecorder, \"mqshqVsTGpdtlP4pslkJUSRDWdw=\");","map":{"version":3,"names":["useState","useCallback","useRef","RECORDING_DURATION","useAudioRecorder","_s","mediaRecorder","setMediaRecorder","isRecording","setIsRecording","audioBlob","setAudioBlob","timerRef","reset","current","clearTimeout","stopRecording","stop","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","recorder","MediaRecorder","chunks","ondataavailable","e","push","data","onstop","blob","Blob","type","getTracks","forEach","track","start","setTimeout","error","console"],"sources":["/Users/4funzzies/Desktop/Claude/App1/frontend/src/hooks/useAudioRecorder.ts"],"sourcesContent":["import { useState, useCallback, useRef } from 'react';\n\ninterface AudioRecorderHook {\n  startRecording: () => Promise<void>;\n  isRecording: boolean;\n  audioBlob: Blob | null;\n  reset: () => void;\n}\n\nconst RECORDING_DURATION = 12; // seconds\n\nexport const useAudioRecorder = (): AudioRecorderHook => {\n  const [mediaRecorder, setMediaRecorder] = useState<MediaRecorder | null>(null);\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioBlob, setAudioBlob] = useState<Blob | null>(null);\n  const timerRef = useRef<NodeJS.Timeout | null>(null);\n\n  const reset = useCallback(() => {\n    setIsRecording(false);\n    setAudioBlob(null);\n    setMediaRecorder(null);\n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n    }\n  }, []);\n\n  const stopRecording = useCallback(() => {\n    if (mediaRecorder && isRecording) {\n      mediaRecorder.stop();\n      setIsRecording(false);\n      \n      if (timerRef.current) {\n        clearTimeout(timerRef.current);\n        timerRef.current = null;\n      }\n    }\n  }, [mediaRecorder, isRecording]);\n\n  const startRecording = useCallback(async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      const recorder = new MediaRecorder(stream);\n      const chunks: BlobPart[] = [];\n\n      recorder.ondataavailable = (e) => chunks.push(e.data);\n      recorder.onstop = () => {\n        const blob = new Blob(chunks, { type: 'audio/webm' });\n        setAudioBlob(blob);\n        stream.getTracks().forEach(track => track.stop());\n      };\n\n      recorder.start();\n      setMediaRecorder(recorder);\n      setIsRecording(true);\n\n      // Automatically stop after RECORDING_DURATION seconds\n      timerRef.current = setTimeout(() => {\n        stopRecording();\n      }, RECORDING_DURATION * 1000);\n\n    } catch (error) {\n      console.error('Error accessing microphone:', error);\n      reset();\n    }\n  }, [stopRecording, reset]);\n\n  return {\n    startRecording,\n    isRecording,\n    audioBlob,\n    reset\n  };\n};"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,WAAW,EAAEC,MAAM,QAAQ,OAAO;AASrD,MAAMC,kBAAkB,GAAG,EAAE,CAAC,CAAC;;AAE/B,OAAO,MAAMC,gBAAgB,GAAGA,CAAA,KAAyB;EAAAC,EAAA;EACvD,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGP,QAAQ,CAAuB,IAAI,CAAC;EAC9E,MAAM,CAACQ,WAAW,EAAEC,cAAc,CAAC,GAAGT,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAACU,SAAS,EAAEC,YAAY,CAAC,GAAGX,QAAQ,CAAc,IAAI,CAAC;EAC7D,MAAMY,QAAQ,GAAGV,MAAM,CAAwB,IAAI,CAAC;EAEpD,MAAMW,KAAK,GAAGZ,WAAW,CAAC,MAAM;IAC9BQ,cAAc,CAAC,KAAK,CAAC;IACrBE,YAAY,CAAC,IAAI,CAAC;IAClBJ,gBAAgB,CAAC,IAAI,CAAC;IACtB,IAAIK,QAAQ,CAACE,OAAO,EAAE;MACpBC,YAAY,CAACH,QAAQ,CAACE,OAAO,CAAC;MAC9BF,QAAQ,CAACE,OAAO,GAAG,IAAI;IACzB;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,MAAME,aAAa,GAAGf,WAAW,CAAC,MAAM;IACtC,IAAIK,aAAa,IAAIE,WAAW,EAAE;MAChCF,aAAa,CAACW,IAAI,CAAC,CAAC;MACpBR,cAAc,CAAC,KAAK,CAAC;MAErB,IAAIG,QAAQ,CAACE,OAAO,EAAE;QACpBC,YAAY,CAACH,QAAQ,CAACE,OAAO,CAAC;QAC9BF,QAAQ,CAACE,OAAO,GAAG,IAAI;MACzB;IACF;EACF,CAAC,EAAE,CAACR,aAAa,EAAEE,WAAW,CAAC,CAAC;EAEhC,MAAMU,cAAc,GAAGjB,WAAW,CAAC,YAAY;IAC7C,IAAI;MACF,MAAMkB,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QAAEC,KAAK,EAAE;MAAK,CAAC,CAAC;MACzE,MAAMC,QAAQ,GAAG,IAAIC,aAAa,CAACN,MAAM,CAAC;MAC1C,MAAMO,MAAkB,GAAG,EAAE;MAE7BF,QAAQ,CAACG,eAAe,GAAIC,CAAC,IAAKF,MAAM,CAACG,IAAI,CAACD,CAAC,CAACE,IAAI,CAAC;MACrDN,QAAQ,CAACO,MAAM,GAAG,MAAM;QACtB,MAAMC,IAAI,GAAG,IAAIC,IAAI,CAACP,MAAM,EAAE;UAAEQ,IAAI,EAAE;QAAa,CAAC,CAAC;QACrDvB,YAAY,CAACqB,IAAI,CAAC;QAClBb,MAAM,CAACgB,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACpB,IAAI,CAAC,CAAC,CAAC;MACnD,CAAC;MAEDO,QAAQ,CAACc,KAAK,CAAC,CAAC;MAChB/B,gBAAgB,CAACiB,QAAQ,CAAC;MAC1Bf,cAAc,CAAC,IAAI,CAAC;;MAEpB;MACAG,QAAQ,CAACE,OAAO,GAAGyB,UAAU,CAAC,MAAM;QAClCvB,aAAa,CAAC,CAAC;MACjB,CAAC,EAAEb,kBAAkB,GAAG,IAAI,CAAC;IAE/B,CAAC,CAAC,OAAOqC,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;MACnD3B,KAAK,CAAC,CAAC;IACT;EACF,CAAC,EAAE,CAACG,aAAa,EAAEH,KAAK,CAAC,CAAC;EAE1B,OAAO;IACLK,cAAc;IACdV,WAAW;IACXE,SAAS;IACTG;EACF,CAAC;AACH,CAAC;AAACR,EAAA,CA9DWD,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
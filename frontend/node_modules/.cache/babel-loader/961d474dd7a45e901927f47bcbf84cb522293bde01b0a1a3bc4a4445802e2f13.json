{"ast":null,"code":"import{useState,useCallback,useRef,useEffect}from'react';const RECORDING_DURATION=12000;// 12 seconds in milliseconds\nexport const useAudioRecorder=()=>{const[mediaRecorder,setMediaRecorder]=useState(null);const[isRecording,setIsRecording]=useState(false);const[audioBlob,setAudioBlob]=useState(null);const timerRef=useRef(null);const streamRef=useRef(null);const reset=useCallback(()=>{setIsRecording(false);setAudioBlob(null);setMediaRecorder(null);if(timerRef.current){window.clearTimeout(timerRef.current);timerRef.current=null;}if(streamRef.current){streamRef.current.getTracks().forEach(track=>track.stop());streamRef.current=null;}},[]);useEffect(()=>{return()=>{reset();};},[reset]);const stopRecording=useCallback(()=>{if(mediaRecorder&&mediaRecorder.state!=='inactive'){mediaRecorder.stop();setIsRecording(false);}if(streamRef.current){streamRef.current.getTracks().forEach(track=>track.stop());}},[mediaRecorder]);const startRecording=useCallback(async()=>{try{reset();const stream=await navigator.mediaDevices.getUserMedia({audio:true});streamRef.current=stream;const recorder=new MediaRecorder(stream);const chunks=[];recorder.ondataavailable=e=>{if(e.data.size>0){chunks.push(e.data);}};recorder.onstop=()=>{const blob=new Blob(chunks,{type:'audio/webm'});setAudioBlob(blob);setIsRecording(false);if(streamRef.current){streamRef.current.getTracks().forEach(track=>track.stop());}};recorder.start(1000);setMediaRecorder(recorder);setIsRecording(true);timerRef.current=window.setTimeout(()=>{stopRecording();},RECORDING_DURATION);}catch(error){console.error('Error accessing microphone:',error);reset();throw error;}},[reset,stopRecording]);return{startRecording,stopRecording,isRecording,audioBlob,reset};};","map":{"version":3,"names":["useState","useCallback","useRef","useEffect","RECORDING_DURATION","useAudioRecorder","mediaRecorder","setMediaRecorder","isRecording","setIsRecording","audioBlob","setAudioBlob","timerRef","streamRef","reset","current","window","clearTimeout","getTracks","forEach","track","stop","stopRecording","state","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","recorder","MediaRecorder","chunks","ondataavailable","e","data","size","push","onstop","blob","Blob","type","start","setTimeout","error","console"],"sources":["/Users/4funzzies/Desktop/Claude/App/frontend/src/hooks/useAudioRecorder.ts"],"sourcesContent":["import { useState, useCallback, useRef, useEffect } from 'react';\n\nconst RECORDING_DURATION = 12000; // 12 seconds in milliseconds\n\nexport const useAudioRecorder = () => {\n  const [mediaRecorder, setMediaRecorder] = useState<MediaRecorder | null>(null);\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioBlob, setAudioBlob] = useState<Blob | null>(null);\n  const timerRef = useRef<number | null>(null);\n  const streamRef = useRef<MediaStream | null>(null);\n\n  const reset = useCallback(() => {\n    setIsRecording(false);\n    setAudioBlob(null);\n    setMediaRecorder(null);\n    if (timerRef.current) {\n      window.clearTimeout(timerRef.current);\n      timerRef.current = null;\n    }\n    if (streamRef.current) {\n      streamRef.current.getTracks().forEach(track => track.stop());\n      streamRef.current = null;\n    }\n  }, []);\n\n  useEffect(() => {\n    return () => {\n      reset();\n    };\n  }, [reset]);\n\n  const stopRecording = useCallback(() => {\n    if (mediaRecorder && mediaRecorder.state !== 'inactive') {\n      mediaRecorder.stop();\n      setIsRecording(false);\n    }\n    if (streamRef.current) {\n      streamRef.current.getTracks().forEach(track => track.stop());\n    }\n  }, [mediaRecorder]);\n\n  const startRecording = useCallback(async () => {\n    try {\n      reset();\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      streamRef.current = stream;\n      \n      const recorder = new MediaRecorder(stream);\n      const chunks: BlobPart[] = [];\n\n      recorder.ondataavailable = (e) => {\n        if (e.data.size > 0) {\n          chunks.push(e.data);\n        }\n      };\n\n      recorder.onstop = () => {\n        const blob = new Blob(chunks, { type: 'audio/webm' });\n        setAudioBlob(blob);\n        setIsRecording(false);\n        if (streamRef.current) {\n          streamRef.current.getTracks().forEach(track => track.stop());\n        }\n      };\n\n      recorder.start(1000);\n      setMediaRecorder(recorder);\n      setIsRecording(true);\n\n      timerRef.current = window.setTimeout(() => {\n        stopRecording();\n      }, RECORDING_DURATION);\n\n    } catch (error) {\n      console.error('Error accessing microphone:', error);\n      reset();\n      throw error;\n    }\n  }, [reset, stopRecording]);\n\n  return {\n    startRecording,\n    stopRecording,\n    isRecording,\n    audioBlob,\n    reset\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
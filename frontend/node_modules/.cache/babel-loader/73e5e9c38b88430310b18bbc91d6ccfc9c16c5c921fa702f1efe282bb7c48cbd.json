{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useRef } from 'react';\nconst RECORDING_DURATION = 12; // seconds\n\nexport const useAudioRecorder = () => {\n  _s();\n  const [mediaRecorder, setMediaRecorder] = useState(null);\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioBlob, setAudioBlob] = useState(null);\n  const timerRef = useRef(null);\n  const stopRecording = useCallback(() => {\n    if (mediaRecorder && isRecording) {\n      mediaRecorder.stop();\n      setIsRecording(false);\n      if (timerRef.current) {\n        clearTimeout(timerRef.current);\n        timerRef.current = null;\n      }\n    }\n  }, [mediaRecorder, isRecording]);\n  const startRecording = useCallback(async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      const recorder = new MediaRecorder(stream);\n      const chunks = [];\n      recorder.ondataavailable = e => chunks.push(e.data);\n      recorder.onstop = () => {\n        const blob = new Blob(chunks, {\n          type: 'audio/webm'\n        });\n        setAudioBlob(blob);\n        stream.getTracks().forEach(track => track.stop());\n      };\n      recorder.start();\n      setMediaRecorder(recorder);\n      setIsRecording(true);\n\n      // Automatically stop after RECORDING_DURATION seconds\n      timerRef.current = setTimeout(() => {\n        stopRecording();\n      }, RECORDING_DURATION * 1000);\n    } catch (error) {\n      console.error('Error accessing microphone:', error);\n    }\n  }, [stopRecording]);\n  return {\n    startRecording,\n    isRecording,\n    audioBlob\n  };\n};\n_s(useAudioRecorder, \"eyN6mIihYOZXxMhjMdDW2y5cM8I=\");","map":{"version":3,"names":["useState","useCallback","useRef","RECORDING_DURATION","useAudioRecorder","_s","mediaRecorder","setMediaRecorder","isRecording","setIsRecording","audioBlob","setAudioBlob","timerRef","stopRecording","stop","current","clearTimeout","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","recorder","MediaRecorder","chunks","ondataavailable","e","push","data","onstop","blob","Blob","type","getTracks","forEach","track","start","setTimeout","error","console"],"sources":["/Users/4funzzies/Desktop/Claude/App1/frontend/src/hooks/useAudioRecorder.ts"],"sourcesContent":["import { useState, useCallback, useRef } from 'react';\n\ninterface AudioRecorderHook {\n  startRecording: () => Promise<void>;\n  isRecording: boolean;\n  audioBlob: Blob | null;\n}\n\nconst RECORDING_DURATION = 12; // seconds\n\nexport const useAudioRecorder = (): AudioRecorderHook => {\n  const [mediaRecorder, setMediaRecorder] = useState<MediaRecorder | null>(null);\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioBlob, setAudioBlob] = useState<Blob | null>(null);\n  const timerRef = useRef<NodeJS.Timeout | null>(null);\n\n  const stopRecording = useCallback(() => {\n    if (mediaRecorder && isRecording) {\n      mediaRecorder.stop();\n      setIsRecording(false);\n      \n      if (timerRef.current) {\n        clearTimeout(timerRef.current);\n        timerRef.current = null;\n      }\n    }\n  }, [mediaRecorder, isRecording]);\n\n  const startRecording = useCallback(async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      const recorder = new MediaRecorder(stream);\n      const chunks: BlobPart[] = [];\n\n      recorder.ondataavailable = (e) => chunks.push(e.data);\n      recorder.onstop = () => {\n        const blob = new Blob(chunks, { type: 'audio/webm' });\n        setAudioBlob(blob);\n        stream.getTracks().forEach(track => track.stop());\n      };\n\n      recorder.start();\n      setMediaRecorder(recorder);\n      setIsRecording(true);\n\n      // Automatically stop after RECORDING_DURATION seconds\n      timerRef.current = setTimeout(() => {\n        stopRecording();\n      }, RECORDING_DURATION * 1000);\n\n    } catch (error) {\n      console.error('Error accessing microphone:', error);\n    }\n  }, [stopRecording]);\n\n  return {\n    startRecording,\n    isRecording,\n    audioBlob\n  };\n};"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,WAAW,EAAEC,MAAM,QAAQ,OAAO;AAQrD,MAAMC,kBAAkB,GAAG,EAAE,CAAC,CAAC;;AAE/B,OAAO,MAAMC,gBAAgB,GAAGA,CAAA,KAAyB;EAAAC,EAAA;EACvD,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGP,QAAQ,CAAuB,IAAI,CAAC;EAC9E,MAAM,CAACQ,WAAW,EAAEC,cAAc,CAAC,GAAGT,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAACU,SAAS,EAAEC,YAAY,CAAC,GAAGX,QAAQ,CAAc,IAAI,CAAC;EAC7D,MAAMY,QAAQ,GAAGV,MAAM,CAAwB,IAAI,CAAC;EAEpD,MAAMW,aAAa,GAAGZ,WAAW,CAAC,MAAM;IACtC,IAAIK,aAAa,IAAIE,WAAW,EAAE;MAChCF,aAAa,CAACQ,IAAI,CAAC,CAAC;MACpBL,cAAc,CAAC,KAAK,CAAC;MAErB,IAAIG,QAAQ,CAACG,OAAO,EAAE;QACpBC,YAAY,CAACJ,QAAQ,CAACG,OAAO,CAAC;QAC9BH,QAAQ,CAACG,OAAO,GAAG,IAAI;MACzB;IACF;EACF,CAAC,EAAE,CAACT,aAAa,EAAEE,WAAW,CAAC,CAAC;EAEhC,MAAMS,cAAc,GAAGhB,WAAW,CAAC,YAAY;IAC7C,IAAI;MACF,MAAMiB,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QAAEC,KAAK,EAAE;MAAK,CAAC,CAAC;MACzE,MAAMC,QAAQ,GAAG,IAAIC,aAAa,CAACN,MAAM,CAAC;MAC1C,MAAMO,MAAkB,GAAG,EAAE;MAE7BF,QAAQ,CAACG,eAAe,GAAIC,CAAC,IAAKF,MAAM,CAACG,IAAI,CAACD,CAAC,CAACE,IAAI,CAAC;MACrDN,QAAQ,CAACO,MAAM,GAAG,MAAM;QACtB,MAAMC,IAAI,GAAG,IAAIC,IAAI,CAACP,MAAM,EAAE;UAAEQ,IAAI,EAAE;QAAa,CAAC,CAAC;QACrDtB,YAAY,CAACoB,IAAI,CAAC;QAClBb,MAAM,CAACgB,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACtB,IAAI,CAAC,CAAC,CAAC;MACnD,CAAC;MAEDS,QAAQ,CAACc,KAAK,CAAC,CAAC;MAChB9B,gBAAgB,CAACgB,QAAQ,CAAC;MAC1Bd,cAAc,CAAC,IAAI,CAAC;;MAEpB;MACAG,QAAQ,CAACG,OAAO,GAAGuB,UAAU,CAAC,MAAM;QAClCzB,aAAa,CAAC,CAAC;MACjB,CAAC,EAAEV,kBAAkB,GAAG,IAAI,CAAC;IAE/B,CAAC,CAAC,OAAOoC,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;IACrD;EACF,CAAC,EAAE,CAAC1B,aAAa,CAAC,CAAC;EAEnB,OAAO;IACLI,cAAc;IACdT,WAAW;IACXE;EACF,CAAC;AACH,CAAC;AAACL,EAAA,CAlDWD,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
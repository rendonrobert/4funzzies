{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback } from 'react';\nexport const useAudioRecorder = () => {\n  _s();\n  const [mediaRecorder, setMediaRecorder] = useState(null);\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioBlob, setAudioBlob] = useState(null);\n  const startRecording = useCallback(async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      const recorder = new MediaRecorder(stream);\n      const chunks = [];\n      recorder.ondataavailable = e => chunks.push(e.data);\n      recorder.onstop = () => {\n        const blob = new Blob(chunks, {\n          type: 'audio/webm'\n        });\n        setAudioBlob(blob);\n        stream.getTracks().forEach(track => track.stop());\n      };\n      recorder.start();\n      setMediaRecorder(recorder);\n      setIsRecording(true);\n    } catch (error) {\n      console.error('Error accessing microphone:', error);\n    }\n  }, []);\n  const stopRecording = useCallback(() => {\n    if (mediaRecorder && isRecording) {\n      mediaRecorder.stop();\n      setIsRecording(false);\n    }\n  }, [mediaRecorder, isRecording]);\n  return {\n    startRecording,\n    stopRecording,\n    isRecording,\n    audioBlob\n  };\n};\n_s(useAudioRecorder, \"4M3FktEce/kPkLu8iNoFm07yqy8=\");","map":{"version":3,"names":["useState","useCallback","useAudioRecorder","_s","mediaRecorder","setMediaRecorder","isRecording","setIsRecording","audioBlob","setAudioBlob","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","recorder","MediaRecorder","chunks","ondataavailable","e","push","data","onstop","blob","Blob","type","getTracks","forEach","track","stop","start","error","console","stopRecording"],"sources":["/Users/4funzzies/Desktop/Claude/App1/frontend/src/hooks/useAudioRecorder.ts"],"sourcesContent":["import { useState, useCallback } from 'react';\n\ninterface AudioRecorderHook {\n  startRecording: () => Promise<void>;\n  stopRecording: () => void;\n  isRecording: boolean;\n  audioBlob: Blob | null;\n}\n\nexport const useAudioRecorder = (): AudioRecorderHook => {\n  const [mediaRecorder, setMediaRecorder] = useState<MediaRecorder | null>(null);\n  const [isRecording, setIsRecording] = useState(false);\n  const [audioBlob, setAudioBlob] = useState<Blob | null>(null);\n\n  const startRecording = useCallback(async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      const recorder = new MediaRecorder(stream);\n      const chunks: BlobPart[] = [];\n\n      recorder.ondataavailable = (e) => chunks.push(e.data);\n      recorder.onstop = () => {\n        const blob = new Blob(chunks, { type: 'audio/webm' });\n        setAudioBlob(blob);\n        stream.getTracks().forEach(track => track.stop());\n      };\n\n      recorder.start();\n      setMediaRecorder(recorder);\n      setIsRecording(true);\n    } catch (error) {\n      console.error('Error accessing microphone:', error);\n    }\n  }, []);\n\n  const stopRecording = useCallback(() => {\n    if (mediaRecorder && isRecording) {\n      mediaRecorder.stop();\n      setIsRecording(false);\n    }\n  }, [mediaRecorder, isRecording]);\n\n  return {\n    startRecording,\n    stopRecording,\n    isRecording,\n    audioBlob\n  };\n};"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,WAAW,QAAQ,OAAO;AAS7C,OAAO,MAAMC,gBAAgB,GAAGA,CAAA,KAAyB;EAAAC,EAAA;EACvD,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGL,QAAQ,CAAuB,IAAI,CAAC;EAC9E,MAAM,CAACM,WAAW,EAAEC,cAAc,CAAC,GAAGP,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAACQ,SAAS,EAAEC,YAAY,CAAC,GAAGT,QAAQ,CAAc,IAAI,CAAC;EAE7D,MAAMU,cAAc,GAAGT,WAAW,CAAC,YAAY;IAC7C,IAAI;MACF,MAAMU,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QAAEC,KAAK,EAAE;MAAK,CAAC,CAAC;MACzE,MAAMC,QAAQ,GAAG,IAAIC,aAAa,CAACN,MAAM,CAAC;MAC1C,MAAMO,MAAkB,GAAG,EAAE;MAE7BF,QAAQ,CAACG,eAAe,GAAIC,CAAC,IAAKF,MAAM,CAACG,IAAI,CAACD,CAAC,CAACE,IAAI,CAAC;MACrDN,QAAQ,CAACO,MAAM,GAAG,MAAM;QACtB,MAAMC,IAAI,GAAG,IAAIC,IAAI,CAACP,MAAM,EAAE;UAAEQ,IAAI,EAAE;QAAa,CAAC,CAAC;QACrDjB,YAAY,CAACe,IAAI,CAAC;QAClBb,MAAM,CAACgB,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACC,IAAI,CAAC,CAAC,CAAC;MACnD,CAAC;MAEDd,QAAQ,CAACe,KAAK,CAAC,CAAC;MAChB1B,gBAAgB,CAACW,QAAQ,CAAC;MAC1BT,cAAc,CAAC,IAAI,CAAC;IACtB,CAAC,CAAC,OAAOyB,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;IACrD;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,MAAME,aAAa,GAAGjC,WAAW,CAAC,MAAM;IACtC,IAAIG,aAAa,IAAIE,WAAW,EAAE;MAChCF,aAAa,CAAC0B,IAAI,CAAC,CAAC;MACpBvB,cAAc,CAAC,KAAK,CAAC;IACvB;EACF,CAAC,EAAE,CAACH,aAAa,EAAEE,WAAW,CAAC,CAAC;EAEhC,OAAO;IACLI,cAAc;IACdwB,aAAa;IACb5B,WAAW;IACXE;EACF,CAAC;AACH,CAAC;AAACL,EAAA,CAvCWD,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
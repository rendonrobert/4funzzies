{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback } from 'react';\nexport const useAudioRecorder = () => {\n  _s();\n  const [isRecording, setIsRecording] = useState(false);\n  const [mediaRecorder, setMediaRecorder] = useState(null);\n  const [audioChunks, setAudioChunks] = useState([]);\n  const startRecording = useCallback(async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      const recorder = new MediaRecorder(stream, {\n        mimeType: 'audio/webm'\n      });\n      recorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          setAudioChunks(chunks => [...chunks, event.data]);\n        }\n      };\n      recorder.onstart = () => {\n        setAudioChunks([]);\n        setIsRecording(true);\n      };\n      setMediaRecorder(recorder);\n      recorder.start();\n\n      // Stop recording after 10 seconds\n      setTimeout(() => {\n        if (recorder.state === 'recording') {\n          recorder.stop();\n          stream.getTracks().forEach(track => track.stop());\n        }\n      }, 10000);\n    } catch (error) {\n      console.error('Error starting recording:', error);\n      throw error;\n    }\n  }, []);\n  const stopRecording = useCallback(() => {\n    return new Promise((resolve, reject) => {\n      if (!mediaRecorder) {\n        reject(new Error('No recording in progress'));\n        return;\n      }\n      mediaRecorder.onstop = () => {\n        const audioBlob = new Blob(audioChunks, {\n          type: 'audio/webm'\n        });\n        setIsRecording(false);\n        setAudioChunks([]);\n        setMediaRecorder(null);\n        resolve(audioBlob);\n      };\n      if (mediaRecorder.state === 'recording') {\n        mediaRecorder.stop();\n        mediaRecorder.stream.getTracks().forEach(track => track.stop());\n      }\n    });\n  }, [mediaRecorder, audioChunks]);\n  return {\n    isRecording,\n    startRecording,\n    stopRecording\n  };\n};\n_s(useAudioRecorder, \"VUWCZsY6T2kaA8oxxR7Cbbn+V/E=\");","map":{"version":3,"names":["useState","useCallback","useAudioRecorder","_s","isRecording","setIsRecording","mediaRecorder","setMediaRecorder","audioChunks","setAudioChunks","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","recorder","MediaRecorder","mimeType","ondataavailable","event","data","size","chunks","onstart","start","setTimeout","state","stop","getTracks","forEach","track","error","console","stopRecording","Promise","resolve","reject","Error","onstop","audioBlob","Blob","type"],"sources":["/Users/4funzzies/Desktop/Claude/App/frontend/src/hooks/useAudioRecorder.ts"],"sourcesContent":["import { useState, useCallback } from 'react';\n\nexport const useAudioRecorder = () => {\n  const [isRecording, setIsRecording] = useState(false);\n  const [mediaRecorder, setMediaRecorder] = useState<MediaRecorder | null>(null);\n  const [audioChunks, setAudioChunks] = useState<Blob[]>([]);\n\n  const startRecording = useCallback(async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      const recorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });\n      \n      recorder.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          setAudioChunks(chunks => [...chunks, event.data]);\n        }\n      };\n\n      recorder.onstart = () => {\n        setAudioChunks([]);\n        setIsRecording(true);\n      };\n\n      setMediaRecorder(recorder);\n      recorder.start();\n      \n      // Stop recording after 10 seconds\n      setTimeout(() => {\n        if (recorder.state === 'recording') {\n          recorder.stop();\n          stream.getTracks().forEach(track => track.stop());\n        }\n      }, 10000);\n      \n    } catch (error) {\n      console.error('Error starting recording:', error);\n      throw error;\n    }\n  }, []);\n\n  const stopRecording = useCallback((): Promise<Blob> => {\n    return new Promise((resolve, reject) => {\n      if (!mediaRecorder) {\n        reject(new Error('No recording in progress'));\n        return;\n      }\n\n      mediaRecorder.onstop = () => {\n        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });\n        setIsRecording(false);\n        setAudioChunks([]);\n        setMediaRecorder(null);\n        resolve(audioBlob);\n      };\n\n      if (mediaRecorder.state === 'recording') {\n        mediaRecorder.stop();\n        mediaRecorder.stream.getTracks().forEach(track => track.stop());\n      }\n    });\n  }, [mediaRecorder, audioChunks]);\n\n  return {\n    isRecording,\n    startRecording,\n    stopRecording\n  };\n};"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,WAAW,QAAQ,OAAO;AAE7C,OAAO,MAAMC,gBAAgB,GAAGA,CAAA,KAAM;EAAAC,EAAA;EACpC,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGL,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAACM,aAAa,EAAEC,gBAAgB,CAAC,GAAGP,QAAQ,CAAuB,IAAI,CAAC;EAC9E,MAAM,CAACQ,WAAW,EAAEC,cAAc,CAAC,GAAGT,QAAQ,CAAS,EAAE,CAAC;EAE1D,MAAMU,cAAc,GAAGT,WAAW,CAAC,YAAY;IAC7C,IAAI;MACF,MAAMU,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QAAEC,KAAK,EAAE;MAAK,CAAC,CAAC;MACzE,MAAMC,QAAQ,GAAG,IAAIC,aAAa,CAACN,MAAM,EAAE;QAAEO,QAAQ,EAAE;MAAa,CAAC,CAAC;MAEtEF,QAAQ,CAACG,eAAe,GAAIC,KAAK,IAAK;QACpC,IAAIA,KAAK,CAACC,IAAI,CAACC,IAAI,GAAG,CAAC,EAAE;UACvBb,cAAc,CAACc,MAAM,IAAI,CAAC,GAAGA,MAAM,EAAEH,KAAK,CAACC,IAAI,CAAC,CAAC;QACnD;MACF,CAAC;MAEDL,QAAQ,CAACQ,OAAO,GAAG,MAAM;QACvBf,cAAc,CAAC,EAAE,CAAC;QAClBJ,cAAc,CAAC,IAAI,CAAC;MACtB,CAAC;MAEDE,gBAAgB,CAACS,QAAQ,CAAC;MAC1BA,QAAQ,CAACS,KAAK,CAAC,CAAC;;MAEhB;MACAC,UAAU,CAAC,MAAM;QACf,IAAIV,QAAQ,CAACW,KAAK,KAAK,WAAW,EAAE;UAClCX,QAAQ,CAACY,IAAI,CAAC,CAAC;UACfjB,MAAM,CAACkB,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACH,IAAI,CAAC,CAAC,CAAC;QACnD;MACF,CAAC,EAAE,KAAK,CAAC;IAEX,CAAC,CAAC,OAAOI,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;MACjD,MAAMA,KAAK;IACb;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,MAAME,aAAa,GAAGjC,WAAW,CAAC,MAAqB;IACrD,OAAO,IAAIkC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAI,CAAC/B,aAAa,EAAE;QAClB+B,MAAM,CAAC,IAAIC,KAAK,CAAC,0BAA0B,CAAC,CAAC;QAC7C;MACF;MAEAhC,aAAa,CAACiC,MAAM,GAAG,MAAM;QAC3B,MAAMC,SAAS,GAAG,IAAIC,IAAI,CAACjC,WAAW,EAAE;UAAEkC,IAAI,EAAE;QAAa,CAAC,CAAC;QAC/DrC,cAAc,CAAC,KAAK,CAAC;QACrBI,cAAc,CAAC,EAAE,CAAC;QAClBF,gBAAgB,CAAC,IAAI,CAAC;QACtB6B,OAAO,CAACI,SAAS,CAAC;MACpB,CAAC;MAED,IAAIlC,aAAa,CAACqB,KAAK,KAAK,WAAW,EAAE;QACvCrB,aAAa,CAACsB,IAAI,CAAC,CAAC;QACpBtB,aAAa,CAACK,MAAM,CAACkB,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACH,IAAI,CAAC,CAAC,CAAC;MACjE;IACF,CAAC,CAAC;EACJ,CAAC,EAAE,CAACtB,aAAa,EAAEE,WAAW,CAAC,CAAC;EAEhC,OAAO;IACLJ,WAAW;IACXM,cAAc;IACdwB;EACF,CAAC;AACH,CAAC;AAAC/B,EAAA,CAjEWD,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}